---
phase: 03-dashboard
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - frontend/src/components/ChartRenderer.tsx
  - frontend/src/App.tsx
  - frontend/src/App.css
autonomous: false

must_haves:
  truths:
    - "AI tool calls render visualizations in dashboard"
    - "show_chart displays a chart component"
    - "show_metrics updates the metrics panel"
    - "Visualizations appear with animation"
  artifacts:
    - path: "frontend/src/components/ChartRenderer.tsx"
      provides: "Chart visualization from tool data"
      min_lines: 60
  key_links:
    - from: "App.tsx"
      to: "WebSocket tool_result"
      via: "handleMessage callback"
      pattern: "tool_result"
    - from: "App.tsx"
      to: "ChartRenderer.tsx"
      via: "render in visualization area"
      pattern: "ChartRenderer"
    - from: "App.tsx"
      to: "Dashboard.tsx"
      via: "pass visualization prop"
      pattern: "visualization="
---

<objective>
Integrate tool call results to render visualizations in the dashboard.

Purpose: Connect backend tool calls to frontend rendering so AI responses trigger visual updates.
Output: Working end-to-end flow where AI can show charts and update metrics via tool calls.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior plans in this phase
@.planning/phases/03-dashboard/03-01-SUMMARY.md
@.planning/phases/03-dashboard/03-02-SUMMARY.md

# Frontend files
@frontend/src/App.tsx
@frontend/src/components/Dashboard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChartRenderer component</name>
  <files>frontend/src/components/ChartRenderer.tsx, frontend/src/App.css</files>
  <action>
Create ChartRenderer component that renders charts from tool call data.

Since we're NOT using a charting library (per PROJECT.md - gpt-image-1-mini will generate chart images later), create a simple visual representation:

Props interface:
```typescript
interface ChartData {
  label: string
  value: number
}

interface ChartRendererProps {
  chartType: 'line' | 'bar' | 'pie' | 'area'
  title: string
  data: ChartData[]
}
```

For MVP, render a simple bar chart using CSS:
- Title at top
- Horizontal bars with labels and values
- Bar width proportional to value (relative to max value)
- Animate bars on mount (CSS transition or keyframe)

Style in App.css:
- `.chart-container` - container with padding
- `.chart-title` - centered title
- `.chart-bar` - horizontal bar with transition
- `.chart-label` - label text
- `.chart-value` - value text

Animation: Bars should grow from 0 width to final width over 0.5s on mount.
  </action>
  <verify>npm run build succeeds</verify>
  <done>ChartRenderer component renders animated bar chart from data</done>
</task>

<task type="auto">
  <name>Task 2: Handle tool_result messages in App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
Update App.tsx to handle tool_result WebSocket messages and render visualizations.

Changes:
1. Add state for visualization content:
   ```typescript
   const [visualization, setVisualization] = useState<React.ReactNode>(null)
   const [dashboardMetrics, setDashboardMetrics] = useState<MetricsPanelProps['metrics']>()
   ```

2. Add tool_result handling in handleMessage callback:
   ```typescript
   else if (message.type === 'tool_result') {
     const { tool, result } = message.payload as { tool: string; result: any }

     if (tool === 'show_chart') {
       setVisualization(
         <ChartRenderer
           chartType={result.chart_type}
           title={result.title}
           data={result.data}
         />
       )
     } else if (tool === 'show_metrics') {
       setDashboardMetrics(result.metrics)
     }
   }
   ```

3. Pass state to Dashboard component:
   ```tsx
   <Dashboard
     metrics={dashboardMetrics}
     visualization={visualization}
   />
   ```

4. Import ChartRenderer component

IMPORTANT: Keep all existing chat handling - this ADDS tool result handling alongside it.
  </action>
  <verify>npm run build succeeds; no TypeScript errors</verify>
  <done>App.tsx handles tool_result messages and passes data to Dashboard</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>End-to-end dashboard visualization flow with AI tool calls</what-built>
  <how-to-verify>
    1. Start backend: cd backend && python main.py
    2. Start frontend: cd frontend && npm run dev
    3. Visit http://localhost:5173
    4. Type: "Show me a chart of monthly sales: January $1000, February $1500, March $2000"
    5. Verify: AI responds AND a bar chart appears in the visualization area
    6. Verify: Bars animate in (grow from left to right)
    7. Type: "Update my metrics to show Temperature: 72Â°F and Humidity: 45%"
    8. Verify: Metrics panel updates with new values
    9. Verify: Chat still works normally for non-visualization questions
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in frontend directory
- [ ] ChartRenderer component exists and renders bar charts
- [ ] App.tsx handles tool_result message type
- [ ] Visualization state passed to Dashboard
- [ ] Human verification approved
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- AI can trigger visualizations via tool calls
- Visualizations render with animation
- Metrics can be updated via tool calls
  </success_criteria>

<output>
After completion, create `.planning/phases/03-dashboard/03-03-SUMMARY.md`
</output>
