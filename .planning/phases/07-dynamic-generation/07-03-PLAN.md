---
phase: 07-dynamic-generation
plan: 03
type: execute
wave: 3
depends_on: ["07-02"]
files_modified: [backend/chat.py, backend/persona.py, backend/modes.py]
autonomous: true

must_haves:
  truths:
    - "Unknown industry triggers generation instead of error"
    - "Generated mode is stored for reuse within session"
    - "Persona generates appropriate data for arbitrary industry"
    - "Mode switch works identically for pre-built and generated modes"
  artifacts:
    - path: "backend/chat.py"
      provides: "Dynamic mode routing"
      contains: "generate_mode"
    - path: "backend/modes.py"
      provides: "Generated mode storage"
      contains: "_generated_modes"
    - path: "backend/persona.py"
      provides: "Generic persona generation"
      contains: "generate_generic_persona"
  key_links:
    - from: "chat.py detect_mode_switch"
      to: "mode_generator.generate_mode"
      via: "await call when industry not found"
      pattern: "await generate_mode"
    - from: "chat.py"
      to: "modes.py store_generated_mode"
      via: "stores result for session reuse"
      pattern: "store_generated_mode"
    - from: "persona.py"
      to: "generate_generic_persona"
      via: "fallback for unknown industries"
      pattern: "generate_generic_persona"
---

<objective>
Integrate the mode generator into the existing chat flow and extend persona generation for arbitrary industries.

Purpose: Complete the dynamic generation feature by wiring the generator to the mode detection flow and ensuring personas work for any industry.

Output: Working end-to-end dynamic mode generation - user says "Presto-Change-O, you're a florist" and gets a complete, functional mode.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dynamic-generation/07-RESEARCH.md
@.planning/phases/07-dynamic-generation/07-02-SUMMARY.md

Existing files to modify:
@backend/chat.py
@backend/modes.py
@backend/persona.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generated mode storage to modes.py</name>
  <files>backend/modes.py</files>
  <action>
Extend modes.py to store dynamically generated modes for session reuse.

**Add at module level (after MODES dict):**

```python
# Storage for dynamically generated modes (session-level cache)
_generated_modes: dict[str, Mode] = {}
```

**Add new functions:**

1. **store_generated_mode(mode: Mode) -> None:**
   - Store mode in _generated_modes by mode.id
   - This allows reuse within the session

2. **get_generated_mode(mode_id: str) -> Mode | None:**
   - Return mode from _generated_modes if exists
   - Return None if not found

3. **Modify get_mode(mode_id: str):**
   - First check MODES (pre-built)
   - Then check _generated_modes (dynamically generated)
   - Return None only if not in either

This way generated modes are transparently accessible through the same get_mode() interface.
  </action>
  <verify>python -c "from backend.modes import store_generated_mode, get_generated_mode, _generated_modes; print('Generated mode storage OK')"</verify>
  <done>Generated mode storage functions added and get_mode checks both sources</done>
</task>

<task type="auto">
  <name>Task 2: Add generic persona generation to persona.py</name>
  <files>backend/persona.py</files>
  <action>
Extend persona.py to generate reasonable personas for arbitrary industries.

**Add new function:**

```python
def generate_generic_persona(mode_id: str, mode_name: str, seed: int) -> dict:
    """
    Generate a generic persona for dynamically generated industries.
    Uses mode name to customize the context but follows a generic structure.
    """
    fake = Faker()
    fake.seed_instance(seed)

    # Generate a generic customer profile
    name = fake.name()
    member_since = fake.date_between(start_date='-5y', end_date='-1y').strftime('%B %Y')

    # Generate some generic metrics that work for any business
    # Use seed for consistency
    account_value = round(fake.pyfloat(min_value=1000, max_value=50000), 2)
    transactions_this_month = fake.random_int(min=5, max=30)
    loyalty_points = fake.random_int(min=100, max=10000)

    return {
        "name": name,
        "customer_since": member_since,
        "account_value": account_value,
        "recent_activity_count": transactions_this_month,
        "loyalty_points": loyalty_points,
        "status": fake.random_element(["Bronze", "Silver", "Gold", "Platinum"]),
        "context_hint": f"This is a {mode_name} customer dashboard."
    }
```

**Modify generate_persona(mode_id: str, seed: int):**
- After checking for banking/insurance/healthcare
- Add fallback: `return generate_generic_persona(mode_id, mode_id.replace('_', ' ').title(), seed)`

This ensures any dynamically generated mode gets a reasonable persona.
  </action>
  <verify>python -c "from backend.persona import generate_generic_persona; p = generate_generic_persona('pet_store', 'Pet Store', 12345); assert 'name' in p and 'account_value' in p; print('Generic persona OK')"</verify>
  <done>Generic persona generation works for arbitrary mode IDs</done>
</task>

<task type="auto">
  <name>Task 3: Wire mode generator into chat.py detect_mode_switch</name>
  <files>backend/chat.py</files>
  <action>
Modify detect_mode_switch() in chat.py to generate modes for unknown industries.

**Current flow:**
1. Detect "Presto-Change-O, you're a [industry]"
2. Extract industry name
3. Look up in MODES
4. If not found, return None (no switch)

**New flow:**
1. Detect "Presto-Change-O, you're a [industry]"
2. Extract industry name
3. Look up with get_mode() (checks MODES + _generated_modes)
4. If found, return mode
5. **If not found, generate:**
   - Call `await generate_mode(industry)` from mode_generator
   - If generation succeeds, store with `store_generated_mode()`
   - Return the generated mode
6. If generation fails, log error and return None

**Changes needed:**

1. **Import at top:**
   ```python
   from backend.mode_generator import generate_mode
   from backend.modes import store_generated_mode
   ```

2. **Make detect_mode_switch async:**
   - Change `def detect_mode_switch(message: str)` to `async def detect_mode_switch(message: str)`
   - This is needed to await the generator

3. **Update callers:**
   - In handle_chat_message(), change call to `await detect_mode_switch(message)`
   - handle_chat_message is already async, so this is straightforward

4. **Add generation logic:**
   After `mode = get_mode(industry)` returns None:
   ```python
   if mode is None:
       # Try to generate mode for unknown industry
       try:
           mode = await generate_mode(industry)
           if mode:
               store_generated_mode(mode)
       except Exception as e:
           print(f"Mode generation failed: {e}")
           mode = None
   ```

**Important:** The generation happens inline in the WebSocket handler. For v1, this is acceptable (2-3 second generation). Phase 8 (Caching) will optimize this.
  </action>
  <verify>python -c "from backend.chat import detect_mode_switch; import inspect; assert inspect.iscoroutinefunction(detect_mode_switch); print('detect_mode_switch is async')"</verify>
  <done>detect_mode_switch is async and imports generate_mode</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from backend.modes import store_generated_mode, get_generated_mode"` succeeds
- [ ] `python -c "from backend.persona import generate_generic_persona"` succeeds
- [ ] `python -c "from backend.chat import detect_mode_switch; import inspect; assert inspect.iscoroutinefunction(detect_mode_switch)"` passes
- [ ] detect_mode_switch imports generate_mode
- [ ] get_mode checks both MODES and _generated_modes
</verification>

<success_criteria>
- All tasks completed
- Unknown industries trigger generation (not error)
- Generated modes stored for session reuse
- Persona generation works for any mode_id
- Mode switch WebSocket message works identically for generated modes
</success_criteria>

<output>
After completion, create `.planning/phases/07-dynamic-generation/07-03-SUMMARY.md`
</output>
