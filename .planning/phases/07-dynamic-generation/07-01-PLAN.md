---
phase: 07-dynamic-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [backend/generation_schemas.py, backend/color_utils.py]
autonomous: true

must_haves:
  truths:
    - "Pydantic schemas define complete mode config structure"
    - "Color utility derives full palette from single primary"
  artifacts:
    - path: "backend/generation_schemas.py"
      provides: "Pydantic models for LLM structured output"
      exports: ["GeneratedModeConfig", "GeneratedTab", "GeneratedMetric"]
    - path: "backend/color_utils.py"
      provides: "Algorithmic color palette derivation"
      exports: ["derive_theme_palette"]
  key_links:
    - from: "generation_schemas.py"
      to: "modes.py Mode/ModeTheme models"
      via: "compatible structure"
      pattern: "ModeTheme|ModeTab|ModeMetric"
---

<objective>
Create generation infrastructure: Pydantic schemas for LLM structured output and algorithmic color palette derivation.

Purpose: Enable Azure OpenAI Structured Outputs to generate mode configs with 100% schema adherence. Derive complete theme palettes algorithmically from a single LLM-suggested primary color (faster than LLM color generation).

Output: Two new modules providing the foundation for dynamic mode generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-dynamic-generation/07-RESEARCH.md
@.planning/phases/07-dynamic-generation/07-CONTEXT.md

Existing mode infrastructure:
@backend/modes.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for LLM structured output</name>
  <files>backend/generation_schemas.py</files>
  <action>
Create Pydantic models for Azure OpenAI Structured Outputs. These schemas define what the LLM generates.

Models to create:

1. **GeneratedTab** - Single tab definition:
   - `id: str` - lowercase identifier (e.g., "inventory")
   - `label: str` - display label (e.g., "Inventory")
   - `icon: str` - emoji icon (e.g., "ðŸ“¦")

2. **GeneratedMetric** - Single KPI/metric:
   - `label: str` - metric name (e.g., "Total Products")
   - `value: str` - display value (e.g., "$12,450" or "847")
   - `unit: str | None` - optional unit (e.g., "/month")

3. **GeneratedModeConfig** - Complete mode configuration:
   - `industry_name: str` - proper name (e.g., "Pet Store")
   - `industry_id: str` - lowercase identifier (e.g., "pet_store")
   - `primary_color: str` - hex color with industry association (e.g., "#4CAF50")
   - `personality_traits: list[str]` - 3-5 traits for AI personality (e.g., ["friendly", "knowledgeable about pets"])
   - `tabs: list[GeneratedTab]` - 4-5 industry-appropriate tabs (always include "dashboard" and "settings")
   - `default_metrics: list[GeneratedMetric]` - 4 industry-appropriate KPIs
   - `welcome_message: str` - greeting when entering mode
   - `system_prompt_fragment: str` - additional context for AI (industry-specific guidance)

Include docstrings explaining each field's purpose. Import from pydantic.
  </action>
  <verify>python -c "from backend.generation_schemas import GeneratedModeConfig, GeneratedTab, GeneratedMetric; print('Schemas OK')"</verify>
  <done>All three Pydantic models importable and validated</done>
</task>

<task type="auto">
  <name>Task 2: Create algorithmic color palette derivation</name>
  <files>backend/color_utils.py</files>
  <action>
Create color utility functions to derive a complete ModeTheme from a single primary color. This is faster than asking the LLM to generate all colors.

**Key insight from research:** LLMs are slow at color generation and often produce poor harmonies. Have LLM suggest only primary color, derive rest algorithmically.

Functions to create:

1. **hex_to_rgb(hex_color: str) -> tuple[int, int, int]**
   - Convert "#1E88E5" to (30, 136, 229)
   - Handle both "#RGB" and "#RRGGBB" formats

2. **rgb_to_hex(r: int, g: int, b: int) -> str**
   - Convert (30, 136, 229) to "#1e88e5"

3. **derive_theme_palette(primary_hex: str) -> dict**
   - Input: single hex color (e.g., "#1E88E5")
   - Output: dict with all ModeTheme fields:
     - `primary`: the input color
     - `secondary`: complementary color (hue +0.5, slightly desaturated)
     - `background`: light (#f8fafc) or dark (#1e293b) based on primary lightness
     - `surface`: white (#ffffff) or dark gray (#334155) based on primary lightness
     - `text`: dark (#0f172a) or light (#f8fafc) based on primary lightness
     - `text_muted`: #64748b (works with both light/dark)

Use `colorsys` module (stdlib) for RGB to HLS conversion. Threshold for light/dark: lightness > 0.5 = use light background.

The frontend already uses CSS `color-mix()` for derived shades - backend just provides the base palette.
  </action>
  <verify>python -c "from backend.color_utils import derive_theme_palette; p = derive_theme_palette('#1E88E5'); assert all(k in p for k in ['primary', 'secondary', 'background', 'surface', 'text', 'text_muted']); print('Color utils OK')"</verify>
  <done>derive_theme_palette returns valid ModeTheme-compatible dict for any input hex color</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `python -c "from backend.generation_schemas import GeneratedModeConfig"` succeeds
- [ ] `python -c "from backend.color_utils import derive_theme_palette"` succeeds
- [ ] derive_theme_palette("#FF0000") returns dict with all 6 theme keys
- [ ] derive_theme_palette("#000088") returns dark-mode-friendly palette
- [ ] GeneratedModeConfig can be instantiated with sample data
</verification>

<success_criteria>
- All tasks completed
- Both modules importable without errors
- Schemas compatible with Azure OpenAI Structured Outputs (Pydantic v2)
- Color derivation produces visually reasonable palettes
</success_criteria>

<output>
After completion, create `.planning/phases/07-dynamic-generation/07-01-SUMMARY.md`
</output>
