---
phase: 02-chat-interface
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - frontend/src/App.tsx
  - frontend/src/components/TypingIndicator.tsx
  - frontend/src/App.css
autonomous: false

must_haves:
  truths:
    - "User can see conversation history with scroll"
    - "User can type and send messages (Enter to send)"
    - "User sees typing indicator when AI is processing"
    - "User sees AI response appear progressively (streaming)"
  artifacts:
    - path: "frontend/src/App.tsx"
      provides: "Chat with streaming display"
      contains: "chat_chunk"
    - path: "frontend/src/components/TypingIndicator.tsx"
      provides: "Typing/loading indicator"
      min_lines: 10
  key_links:
    - from: "App.tsx"
      to: "WebSocket onMessage"
      via: "chat_chunk handling"
      pattern: "chat_chunk|chat_start"
    - from: "App.tsx"
      to: "TypingIndicator"
      via: "conditional render"
      pattern: "isTyping|TypingIndicator"
---

<objective>
Add streaming message display and typing indicators to the frontend chat interface.

Purpose: Complete the chat experience by showing real-time AI responses as they stream from the backend, with visual feedback during processing.

Output: Frontend that displays streaming AI responses progressively with typing indicator.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-chat-interface/02-01-SUMMARY.md

Existing source files:
@frontend/src/App.tsx
@frontend/src/App.css
@frontend/src/hooks/useWebSocket.ts
@frontend/src/lib/websocket.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create typing indicator component</name>
  <files>frontend/src/components/TypingIndicator.tsx, frontend/src/App.css</files>
  <action>
Create `frontend/src/components/TypingIndicator.tsx`:

```tsx
export function TypingIndicator() {
  return (
    <div className="typing-indicator">
      <div className="typing-dot"></div>
      <div className="typing-dot"></div>
      <div className="typing-dot"></div>
    </div>
  )
}
```

Add CSS to App.css for the typing indicator:
- Three bouncing dots animation
- Dark theme compatible (use existing color scheme)
- Position in chat message area like an assistant message
- Animation: dots bounce sequentially with staggered delay

CSS pattern:
```css
.typing-indicator {
  display: flex;
  gap: 4px;
  padding: 12px 16px;
}
.typing-dot {
  width: 8px;
  height: 8px;
  background: #64748b;
  border-radius: 50%;
  animation: typing-bounce 1.4s infinite ease-in-out;
}
.typing-dot:nth-child(2) { animation-delay: 0.2s; }
.typing-dot:nth-child(3) { animation-delay: 0.4s; }
@keyframes typing-bounce {
  0%, 80%, 100% { transform: translateY(0); }
  40% { transform: translateY(-6px); }
}
```

Create components directory if it doesn't exist.
  </action>
  <verify>Check that frontend/src/components/TypingIndicator.tsx exists and exports TypingIndicator</verify>
  <done>TypingIndicator component exists with bouncing dots animation</done>
</task>

<task type="auto">
  <name>Task 2: Add streaming message handling to App.tsx</name>
  <files>frontend/src/App.tsx</files>
  <action>
Update App.tsx to handle streaming messages from backend:

1. Add state for typing indicator: `const [isTyping, setIsTyping] = useState(false)`
2. Add state for streaming message: `const [streamingMessage, setStreamingMessage] = useState<string>('')`
3. Import TypingIndicator component

4. Update useWebSocket to handle message types:
   - Use useEffect to watch `lastMessage` from useWebSocket
   - Handle message types:
     - `chat_start`: Set isTyping=true, create new assistant message placeholder
     - `chat_chunk`: Append chunk.text to current message, if chunk.done=true then finalize message and set isTyping=false
     - Other types: ignore or log

5. Update message display:
   - Show typing indicator when isTyping is true (after messages, before input)
   - When streaming, update the last assistant message progressively
   - Use a streaming message ID to track which message is being streamed

6. Remove the placeholder setTimeout response (the fake "Phase 2" message) - now responses come from real backend

7. Keep existing functionality:
   - Enter to send
   - Scroll behavior
   - Connection status indicator
   - Message input disabled when not connected

Message handling pattern:
```tsx
useEffect(() => {
  if (!lastMessage) return

  if (lastMessage.type === 'chat_start') {
    setIsTyping(true)
    // Add placeholder message that will be filled
  } else if (lastMessage.type === 'chat_chunk') {
    const { text, done } = lastMessage.payload as { text: string; done: boolean }
    if (done) {
      setIsTyping(false)
    } else {
      // Append text to current streaming message
    }
  }
}, [lastMessage])
```
  </action>
  <verify>npm run build in frontend directory succeeds with no TypeScript errors</verify>
  <done>App.tsx handles streaming messages, shows typing indicator, progressively renders AI responses</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete chat interface with streaming AI responses and typing indicators</what-built>
  <how-to-verify>
    1. Start backend: cd backend && python -m uvicorn main:app --reload
    2. Start frontend: cd frontend && npm run dev
    3. Open http://localhost:5173
    4. Verify connection status shows green (connected)
    5. Type a message and press Enter
    6. Verify: Typing indicator (bouncing dots) appears
    7. Verify: AI response streams in progressively (not all at once)
    8. Verify: Typing indicator disappears when response completes
    9. Verify: Can scroll through conversation history
    10. Test multiple messages to confirm conversation works

    Note: Backend requires Azure auth - a browser popup may appear for login on first message.
  </how-to-verify>
  <resume-signal>Type "approved" if chat works with streaming, or describe issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in frontend directory
- [ ] TypingIndicator component exists and renders
- [ ] App.tsx handles chat_start and chat_chunk message types
- [ ] No hardcoded placeholder responses remain
- [ ] Human verification approved
</verification>

<success_criteria>
- All tasks completed
- All verification checks pass
- Chat messages stream progressively from AI
- Typing indicator shows during processing
- Human approved the chat experience
</success_criteria>

<output>
After completion, create `.planning/phases/02-chat-interface/02-02-SUMMARY.md`
</output>
