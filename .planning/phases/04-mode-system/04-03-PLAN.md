---
phase: 04-mode-system
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - frontend/src/context/ModeContext.tsx
  - frontend/src/App.tsx
  - frontend/src/App.css
autonomous: false

must_haves:
  truths:
    - "User can say 'Presto-Change-O, you're a bank' and interface theme changes"
    - "User can say 'Presto-Change-O, you're an insurance company' and theme changes"
    - "User can say 'Presto-Change-O, you're a healthcare provider' and theme changes"
    - "Tabs update to match the current industry mode"
    - "Metrics update to show industry-appropriate data"
  artifacts:
    - path: "frontend/src/context/ModeContext.tsx"
      provides: "React context for current mode"
      min_lines: 30
    - path: "frontend/src/App.tsx"
      provides: "Mode context integration, theme application"
      contains: "mode_switch"
  key_links:
    - from: "frontend/src/App.tsx"
      to: "CSS custom properties"
      via: "document.documentElement.style.setProperty"
      pattern: "setProperty.*--theme"
    - from: "WebSocket mode_switch message"
      to: "ModeContext"
      via: "setMode in handleMessage"
      pattern: "mode_switch.*setMode"
---

<objective>
Integrate mode system into frontend with React context, theme application, and dynamic tabs.

Purpose: Complete the mode system by making the frontend respond to mode switches with visual theming and tab updates.
Output: Working end-to-end mode switching with visual verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
@~/.claude/get-shit-done/references/checkpoints.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Previous plans establish types and backend
@.planning/phases/04-mode-system/04-01-SUMMARY.md
@.planning/phases/04-mode-system/04-02-SUMMARY.md

# Current frontend files
@frontend/src/App.tsx
@frontend/src/App.css
@frontend/src/types/mode.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ModeContext provider</name>
  <files>frontend/src/context/ModeContext.tsx</files>
  <action>
Create `frontend/src/context/ModeContext.tsx`:

```typescript
import { createContext, useContext, useState, useCallback, type ReactNode } from 'react'
import type { Mode, ModeTheme, ModeTab } from '../types/mode'

// Default banking mode (matches backend default)
const defaultMode: Mode = {
  id: 'banking',
  name: 'Banking',
  theme: {
    primary: '#1E88E5',
    secondary: '#43A047',
    background: '#f8fafc',
    surface: '#ffffff',
    text: '#0f172a',
    textMuted: '#64748b',
  },
  tabs: [
    { id: 'dashboard', label: 'Dashboard', icon: 'ðŸ“Š' },
    { id: 'accounts', label: 'Accounts', icon: 'ðŸ’³' },
    { id: 'transfers', label: 'Transfers', icon: 'ðŸ’¸' },
    { id: 'payments', label: 'Payments', icon: 'ðŸ“‹' },
    { id: 'settings', label: 'Settings', icon: 'âš™ï¸' },
  ],
  systemPrompt: '',  // Not used on frontend
  defaultMetrics: [
    { label: 'Account Balance', value: '$24,856.42' },
    { label: 'Recent Transactions', value: 12 },
    { label: 'Pending Payments', value: 3 },
    { label: 'Credit Score', value: 742 },
  ],
}

interface ModeContextValue {
  mode: Mode
  setMode: (mode: Mode) => void
}

const ModeContext = createContext<ModeContextValue | null>(null)

function applyTheme(theme: ModeTheme) {
  const root = document.documentElement
  root.style.setProperty('--theme-primary', theme.primary)
  root.style.setProperty('--theme-secondary', theme.secondary)
  root.style.setProperty('--theme-background', theme.background)
  root.style.setProperty('--theme-surface', theme.surface)
  root.style.setProperty('--theme-text', theme.text)
  root.style.setProperty('--theme-text-muted', theme.textMuted)
}

export function ModeProvider({ children }: { children: ReactNode }) {
  const [mode, setModeState] = useState<Mode>(defaultMode)

  const setMode = useCallback((newMode: Mode) => {
    setModeState(newMode)
    applyTheme(newMode.theme)
  }, [])

  return (
    <ModeContext.Provider value={{ mode, setMode }}>
      {children}
    </ModeContext.Provider>
  )
}

export function useMode() {
  const context = useContext(ModeContext)
  if (!context) {
    throw new Error('useMode must be used within a ModeProvider')
  }
  return context
}
```

Create the context directory if it doesn't exist.
  </action>
  <verify>
    - `npx tsc --noEmit` succeeds
    - File exists at frontend/src/context/ModeContext.tsx
  </verify>
  <done>ModeContext provider created with theme application logic</done>
</task>

<task type="auto">
  <name>Task 2: Integrate mode context and handle mode_switch messages</name>
  <files>frontend/src/App.tsx</files>
  <action>
Update `frontend/src/App.tsx`:

1. Add imports at top:
```typescript
import { ModeProvider, useMode } from './context/ModeContext'
import type { Mode } from './types/mode'
```

2. Create an inner AppContent component that uses the mode context (move most of App's content into this):
```typescript
function AppContent() {
  // All existing state and logic moves here
  const { mode, setMode } = useMode()
  // ... rest of component
}
```

3. Wrap the return in ModeProvider:
```typescript
function App() {
  return (
    <ModeProvider>
      <AppContent />
    </ModeProvider>
  )
}
```

4. In the `handleMessage` callback, add handling for `mode_switch` message type:
```typescript
} else if (message.type === 'mode_switch') {
  const { mode: newMode } = message.payload as { mode: Mode }
  setMode(newMode)
  // Update metrics to new mode defaults
  setDashboardMetrics(newMode.defaultMetrics)
  // Clear visualization on mode switch
  setVisualization(null)
}
```

5. Update the tabs rendering to use `mode.tabs` instead of hardcoded tabs:
```typescript
// Remove the hardcoded tabs array
// Replace tabs.map with mode.tabs.map in the JSX:
{mode.tabs.map(tab => (
  <button
    key={tab.id}
    className={`tab-button ${activeTab === tab.id ? 'active' : ''}`}
    onClick={() => setActiveTab(tab.id)}
  >
    <span className="tab-icon">{tab.icon}</span>
    <span className="tab-label">{tab.label}</span>
  </button>
))}
```

6. Update the initial welcome message to mention the current mode:
```typescript
const [messages, setMessages] = useState<ChatMessage[]>([
  {
    id: '1',
    role: 'assistant',
    content: 'Hello! I\'m your Banking assistant. Say "Presto-Change-O, you\'re an insurance company" or "...you\'re a healthcare provider" to transform this interface!',
    timestamp: new Date()
  }
])
```

7. Update the new chat button to include mode in the reset:
```typescript
const handleNewChat = () => {
  setMessages([{
    id: '1',
    role: 'assistant',
    content: `Hello! I'm your ${mode.name} assistant. Say "Presto-Change-O, you're a bank/insurance/healthcare" to transform this interface!`,
    timestamp: new Date()
  }])
  // Reset visualization and metrics to current mode defaults
  setVisualization(null)
  setDashboardMetrics(mode.defaultMetrics)
  send({ type: 'clear_chat', payload: {} })
}
```

8. Initialize dashboardMetrics with mode.defaultMetrics:
```typescript
// In AppContent, after getting mode from useMode:
const [dashboardMetrics, setDashboardMetrics] = useState<Metric[] | undefined>(mode.defaultMetrics)
```
  </action>
  <verify>
    - `npm run build` succeeds
    - No TypeScript errors
    - App.tsx imports ModeProvider and useMode
    - handleMessage includes mode_switch case
  </verify>
  <done>Mode context integrated, mode_switch handling implemented, dynamic tabs rendering</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete mode switching system with three industries (Banking, Insurance, Healthcare) featuring dynamic theming and tabs</what-built>
  <how-to-verify>
    1. Start backend: `cd backend && python main.py`
    2. Start frontend: `cd frontend && npm run dev`
    3. Open http://localhost:5173

    Test Banking (default):
    - Dashboard should show blue theme
    - Tabs: Dashboard, Accounts, Transfers, Payments, Settings
    - Metrics: Account Balance, Recent Transactions, etc.

    Test Insurance mode:
    - Type: "Presto-Change-O, you're an insurance company"
    - Dashboard should change to purple theme
    - Tabs should change: Dashboard, Policies, Claims, Coverage, Settings
    - Metrics should update: Active Policies, Total Coverage, etc.
    - AI should respond with welcome message

    Test Healthcare mode:
    - Type: "Presto-Change-O, you're a healthcare provider"
    - Dashboard should change to cyan/teal theme
    - Tabs should change: Dashboard, Appointments, Records, Prescriptions, Settings
    - Metrics should update: Upcoming Appointments, Active Prescriptions, etc.

    Test switching back:
    - Type: "Presto-Change-O, you're a bank"
    - Should return to blue banking theme

    Verify:
    - Colors change smoothly (no flash)
    - Tabs update immediately
    - Metrics update to industry-appropriate values
    - Chat history clears on mode switch
    - AI personality matches industry
  </how-to-verify>
  <resume-signal>Type "approved" to complete Phase 4, or describe any issues to fix</resume-signal>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] `npm run build` succeeds in frontend directory
- [ ] Backend starts without errors
- [ ] Mode switching works for all three modes
- [ ] Themes apply correctly (colors, backgrounds)
- [ ] Tabs update per mode
- [ ] Metrics update per mode
- [ ] Human verification approved
</verification>

<success_criteria>

- All tasks completed
- All verification checks pass
- No errors or warnings introduced
- All three modes switch correctly
- Visual theming applies immediately
- Tabs and metrics adapt per industry
  </success_criteria>

<output>
After completion, create `.planning/phases/04-mode-system/04-03-SUMMARY.md`
</output>
